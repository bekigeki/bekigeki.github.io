---
title: "Preprocessing"
author: "Toni Wöhrl"
editor_options: 
  chunk_output_type: console
---

# Setup {.hidden .unlisted}


```{r}
library(tidyverse)
library(dplyr)
library(kableExtra)
library(readxl)
library(sf)
library(jsonlite)
library(reactable)
library(crosstalk)
library(htmltools)
library(tippy)
```



# Daten {.hidden .unlisted}

## Schuladressen

```{r}
# Schulen Geodata
schulen <- read.csv(file="./data/schuladressen-TH-2023-01-18-geocode.csv",
                    colClasses = "character")
summary(schulen)
```

## Politische Grenzen

### Kreise

```{r}
# Kreise Deutschlandweit
kreise <- sf::st_read("./data/sg.geodatenzentrum.de/2023-01-24/vg5000_12-31.utm32s.shape.ebenen/vg5000_ebenen_1231/VG5000_KRS.shp")

# Kreise Thueringen
kreise_th <- subset(kreise, grepl("^16",as.character(kreise$ARS)))
plot(kreise_th$geometry)
kreise_th_t<- st_transform(kreise_th$geometry, crs = "+proj=longlat +datum=WGS84")
```

## BeKiGeki

### 2022

```{r}
# 2022 Daten
d2022 <- read.csv(file="./data/bekigeki_data_2022.csv",
                  colClasses = "character") 
colnames(d2022)
```

### Vor 2022
```{r}
# Daten vor 2022
d_vor_2022 <- read_excel(path="./data/bekigeki_17-21.xlsx",
                col_types = "text")
colnames(d_vor_2022)
```

### 2017 - 2022
```{r}
d <-  dplyr::bind_rows(d2022, d_vor_2022)
```

## Merge tables

```{r}
df <- merge(d,schulen,
            by.x="School",
            by.y="Schulnummer")

nrow(df) - nrow(d)
```

### Finde unmerged data {-}
```{r}
unique(d[!d$School %in% schulen$Schulnummer,"School"])
# "12643" "25816" ? falsche Schulnummern
# d2022[which(d2022$School=="12643"),"Name"] #"Staatliche Grundschule Neudietendorf"
# d2022[which(d2022$School=="25816"),"Name"]
```

# Assign Child IDs
```{r}
# assign Child-IDs
df$Child <- paste0("C",as.character(sprintf("%06d",as.numeric(rownames(df)))))

```

# TODO Errors

+ school administrative area may change, use inkar definition!

```{r}
df$Sex <- tolower(df$Sex)
df_debug <- df |>  
  mutate(Sex = ifelse((Sex == "m" | Sex =="w") & !is.na(Sex),
                      Sex,"unbekannt")) |>
  rename(Cohort = cohort)

# lost data
sex_not_selected <- dplyr::filter(df_debug,Sex=="unbekannt")
count(sex_not_selected)

# NaN Georgenschule Eisenach 11442

a <- d[d$School=="11442",]
```


# TODO fitness classification: zScores and classification of talents T, foerderbeduerftig and erwartungsgemaess
+ second norm file include
- Nächste Frage wäre dann, ob die auf NA gesetzt werden, oder adjustiert, also auf die obere Grenze. Bei SLJ würden 28 nach oben und 89 nach unten rausfallen (nach unten sind einige bei um “1”, die würde ich evtl. zu 100 ändern (cm und m vertauscht?!)). Wäre auch diskutabel ob wir 4 SD nehmen oder 3,29 (0,1 %) ?! Wir könnten das auch nochmal mit Reinhold in einem nächsten Meeting besprechen, ich kann das etwas zusammenfassen (Ideen zu unserer Klassifikation).
Vergleich 3SD zu 4SD upper und lower outliers. Wir sollten das wirklich mit Christian und Reinhold besprechen. Wenn wir uns auf ein Vorgehen festgelegt haben, müssten wir die Korrekturschritte und Normberechnung auch in unser Skript für die Urkunden einbauen. Wenn z.B. beim SLJ wirklich einige mit 1 cm berechnet wurden anstelle des 1 m, hat das nämlich manche ziemlich nach “unten” gezogen. Evtl. sollten wir noch eine Norm-Variante dazu simulieren und zusätzlich z.B. die Klassifikation an der ANZAHL (und nicht mean) an überdurchschnittlichen und unterdurchschnittlichen Testergebnissen vornehmen (Talente: mind 5 von 6 oberhalb der Schwelle, Förderbedarf: mind. 3 unterhalb der Schwelle), oder so (“Inselbegabung” würde dadurch weniger beachtet, bzw. Artefakte oder Extremwerte fielen weniger stark ins Gewicht).

```{r}
# means and sd from external Dataset (Brandenburg until 2017)
norm_BB <- read_excel("./data/norm_171207_v01.xlsx",skip=1) |>
  dplyr::select(Component,Sex,AM_BB,STD_BB)|>
  drop_na()

Component <- c("Star","Run","S20","BPT","SLJ","OLB")

# long format

df_long <- df_debug |> 
  pivot_longer(cols=Component,
               names_to = "Component",
               values_to = "score")|>
  mutate(score = as.numeric(score),
        # change 0 values to NA
        score = ifelse(score==0,NA,score))|>
  dplyr::select(-Filename) |>
  # zScore based on all years
  group_by(Sex, Component) |> 
  mutate(zScore_All  = scale(score),
         q_Upper_All = quantile(score,.80,na.rm=TRUE),
         q_Lower_All = quantile(score,.20,na.rm=TRUE))|>  
  # zScore per Year
  group_by(Sex, Component, Cohort) |> 
  mutate(zScore_Cohort  = scale(score),
         q_Upper_Cohort = quantile(score,.80,na.rm=TRUE),
         q_Lower_Cohort = quantile(score,.20,na.rm=TRUE)) |> 
  # zScore based on external Brandenburg Data
  # also keep "unbekanntes" Geschlecht all=TRUE
  merge(norm_BB,by=c("Component","Sex"),all=TRUE)|> 
  mutate(zScore_BB = (score-AM_BB)/STD_BB)|>
  # invert Score for Component "S20" and "Star" (lower values are better)
  mutate(zScore_BB = ifelse(Component=="S20" | Component == "Star",
                            -zScore_BB,zScore_BB),
         zScore_Cohort = ifelse(Component=="S20" | Component == "Star",
                                -zScore_Cohort,zScore_Cohort),
         zScore_All = ifelse(Component=="S20" | Component == "Star",
                               -zScore_All,zScore_All),
         # do not invert quantile later, use logical expression later
         
         )|>
  mutate(# adjust outliers to 3.29 standard deviation boundaries 
        # (0.1 % of students)
        zScore_All_adj = ifelse(zScore_All > 3.29,3.29,
                           ifelse(zScore_All< -3.29,-3.29,zScore_All))
         )

# summary

df_summary <- df_long |> 
  group_by(Child,Sex) |>
  summarise(
    # count upper quantiles
    qLowerAll = sum((score <= q_Lower_All & (Component!="S20" | Component != "Star")) | 
                      (score >= q_Upper_All & (Component=="S20" | Component == "Star")),na.rm=TRUE),
    qUpperAll = sum((score >= q_Upper_All & (Component!="S20" | Component != "Star")) |
                      (score <= q_Lower_All & (Component=="S20" | Component == "Star")),na.rm=TRUE),
    qLowerCohort = sum((score <= q_Lower_Cohort & (Component!="S20" | Component != "Star")) |
                         (score >= q_Upper_Cohort & (Component=="S20" | Component == "Star")),na.rm=TRUE),
    qUpperCohort = sum((score >= q_Upper_Cohort & (Component!="S20" | Component != "Star")) |
                         (score <= q_Lower_Cohort & (Component=="S20" | Component == "Star")),na.rm=TRUE),
    qAll = qUpperAll - qLowerAll,
    qCohort = qUpperCohort - qLowerCohort,
    # count number of over/under average performances
    zScore_High  = sum(zScore_All_adj >= 0.674,na.rm=TRUE),
    zScore_Low = sum(zScore_All_adj <= -0.674,na.rm=TRUE),
      zScore_All_mean = mean(zScore_All),
    # get mean even if student hasn't performed all tests 
    zScore_All_mean_NA = mean(zScore_All,na.rm=TRUE),
    # set NAs to 0 if student performed at least 3 Tests
    zScore_All_mean_0 = ifelse(sum(is.na(zScore_All)) < 4,
                               sum(zScore_All,na.rm=TRUE)/6,NA),
    # same as before, but with adjusted zScore
    zScore_All_mean_0_adj = ifelse(sum(is.na(zScore_All_adj)) < 4,
                                   sum(zScore_All_adj,na.rm=TRUE)/6,NA),
    # cohort based mean score
    zScore_Cohort_mean = mean(zScore_Cohort),
    # get mean even if student hasn't performed all tests
    zScore_Cohort_mean_NA = mean(zScore_Cohort,na.rm=TRUE),
    # Brandenburg until including 2016
    zScore_BB_mean = mean(zScore_BB),
    Absence = sum(is.na(zScore_All)))|>
  dplyr::filter(Sex == "m" | Sex == "w")|>
  mutate(
    Fitness_q_All = ifelse(Absence<4,
                           ifelse(qAll <=-2,"F",
                                  ifelse(qAll>=2,"T",
                                         ifelse(qAll<2 & qAll>-2,"N",NA))),NA),
    Fitness_q_Cohort = ifelse(Absence<4,
                              ifelse(qCohort <=-2,"F",
                                     ifelse(qCohort>=2,"T",
                                            ifelse(-qCohort<2 & qCohort>-2,"N",NA))),NA),
    Fitness_q_Cohort_T6 = ifelse(Absence<4,
                              ifelse(qCohort <=-2,"F",
                                     ifelse(qCohort>=2 & Absence ==0 ,"T",
                                            ifelse((-qCohort<2 & qCohort>-2) | qCohort>=2 & Absence !=0,"N",NA))),NA),
    
    Fitness_All =ifelse(zScore_All_mean<=-0.674,"F",
                             ifelse(zScore_All_mean >=0.674,"T",
                                    ifelse(zScore_All_mean >=
                                             -0.674 & 
                                             zScore_All_mean <=0.674,
                                           "N",NA))),
         Fitness_Cohort = ifelse(zScore_Cohort_mean<=-0.674,"F",
                                 ifelse(zScore_Cohort_mean >=0.674,"T",
                                        "N")),
         Fitness_Cohort_NA = ifelse(Absence<4,
                                    ifelse(zScore_Cohort_mean_NA<=-0.674,"F",
                                           ifelse((zScore_Cohort_mean_NA > -0.674 
                                                   & zScore_Cohort_mean_NA < 0.674) 
                                                  | (zScore_Cohort_mean_NA >= 0.674 
                                                     & Absence > 0),"N",
                                                  ifelse(zScore_Cohort_mean_NA >= 0.674 
                                                         & Absence == 0,"T",NA))),NA),
         Fitness_All_Absence = ifelse(Absence<4, # minimum 3 Tests are required for evaluation
                                       ifelse(zScore_All_mean_NA<=-0.674,"F",
                                              ifelse((zScore_All_mean_NA > -0.674 
                                                      & zScore_All_mean_NA < 0.674) 
                                                     | (zScore_All_mean_NA >= 0.674 & 
                                                            Absence > 1
                                                        ),"N",
                                                     ifelse(zScore_All_mean_NA >= 0.674 
                                                            & Absence < 2,"T",NA))),NA),
         # if a student performed only 5 out of 6 Tests, for instance,
         # set zScore of missing test to 0 instead of NA:
         # Talents: it will get harder to get classified as a Talent, since 
         # one Test-Result is set to "average", otherwise (if non-test would
         # be NA, they would only take part in their preferred tests)
         # Foerderbeduerftige instead, would benefit from this solution, since
         # it pushes one Test to an averages value
         Fitness_All_Absence_0 = ifelse(Absence<4, # minimum 3 Tests are required for evaluation
                                         ifelse(zScore_All_mean_0<=-0.674,"F",
                                                ifelse((zScore_All_mean_0 > -0.674 
                                                        & zScore_All_mean_0 < 0.674) 
                                                       | (zScore_All_mean_0 >= 0.674 & 
                                                            Absence > 1
                                                          ),"N",
                                             ifelse(zScore_All_mean_0 >= 0.674 
                                                    & Absence < 2,"T",NA))),NA),
         # use previous version with outlier adjustments
         # if a measurement is extremely high (potential error, or real super
         # good performance), this would over-benefit them in their average score 
         # which is used to classify them (Inselbegabung vs. effect of extreme measurement)
         # This version dampens this
         Fitness_All_Absence_0_adj = ifelse(Absence<4, # minimum 3 Tests are required for evaluation
                                         ifelse(zScore_All_mean_0_adj<=-0.674,"F",
                                                ifelse((zScore_All_mean_0_adj > -0.674 
                                                        & zScore_All_mean_0_adj < 0.674) 
                                                       | (zScore_All_mean_0_adj >= 0.674 & 
                                                            Absence > 1
                                                          ),"N",
                                                       ifelse(zScore_All_mean_0_adj >= 0.674 
                                                              & Absence < 2,"T",NA))),NA),
         Fitness_All_Count_0_adj = ifelse(Absence<4, # minimum 3 Tests are required for evaluation
                                         ifelse(zScore_Low>2 & zScore_High ==0,"F",
                                                
                                                ifelse(zScore_High > 3 & Absence < 2,"T",
                                                       "N")),NA),
         # consider number of very good and very bad Test-Component result
         # Talen-Förderbedarfs-Klassifikation:
         #-----------------------------------
         # Test-Teilnahmen: 
         # - mind. 3 (Absence < 4)
         # - Talente mind. 4 (Absence < 2, bzw. hohe "Ambition")
         # - z-Werte nicht absolvierter Tests wird auf 0 gesetzt 
         #    - Talente müssen in anderen Tests umso besser sein
         #.     (keine Rosinenpicker)
         #    - Förderbedürftige werden "etwas nach oben gezogen"
         # Anzahl überdurchschnittlicher Tests 
         # - Talente: zScore_High - zScore_Low>3
         # - Förderbedarf: zScore_Low - zScore_High>3
         # Outlier-Adjustierung (0.1 %)
         # - Deckeln: ifelse(zScore_All > 3.29,3.29,...) 
         # - einzelne Tests sollen nicht zu viel Einfluss auf den Gesamtscore 
         #.  haben (Extremwerte, Messfehler,...) 
         # - trotzdem sollen "Inselbegabungen" Berücksichtigung finden (0,1% Schwelle) 
         # Dynamische Anpassung
         # - alle Jahre vor dem aktuellen Testjahr
         # 0.674 er Gesamtscore-Schwelle vs. (direkte) Quartil-Berechnung
         
         Fitness_All_Absence_Count_0_adj = 
           ifelse(Absence<4, # minimum 3 Tests are required for evaluation
                  ifelse(zScore_All_mean_0_adj<=-0.674 | 
                           (zScore_Low - zScore_High>3),"F",
                         ifelse((zScore_All_mean_0_adj > -0.674 
                                 & zScore_All_mean_0_adj < 0.674 & (zScore_High - zScore_Low<4)) 
                                | (zScore_All_mean_0_adj >= 0.674 & 
                                     Absence > 1 &  (zScore_High - zScore_Low<4)),"N",
                                ifelse((zScore_All_mean_0_adj >= 0.674 
                                        & Absence < 2) |
                                         (zScore_High - zScore_Low>3)
                                       ,"T",NA))),NA),
         
         Fitness_BB = cut(zScore_BB_mean,
                          breaks=c(-Inf,-0.674,0.6734,Inf),
                          right=TRUE,
                          labels=c("F","N","T"))) |>
  mutate(
         # How many differ in dynamic Fitness classification?
         Fitness_Differ_Cohort_All = ifelse(Fitness_Cohort==Fitness_All,
                                 TRUE,FALSE),
         Fitness_Differ_BB_All = ifelse(Fitness_BB==Fitness_All,
                                 TRUE,FALSE),
         Fitness_Differ_BB_Cohort = ifelse(Fitness_BB==Fitness_Cohort,
                                 TRUE,FALSE),
         Fitness_Differ_Absence_0_adj = ifelse(Fitness_All_Absence_0_adj==Fitness_All_Absence_0,
                                 TRUE,FALSE),
         Fitness_Differ_Absence_Count_0_adj = ifelse(Fitness_All_Absence_0_adj==Fitness_All_Count_0_adj,
                                 TRUE,FALSE),
         Fitness_Differ_q_Count_0_adj = ifelse(Fitness_All_Absence_Count_0_adj==Fitness_q_All,
                                 TRUE,FALSE)
         )

# How many differ in Fitness classification?
sum(!df_summary$Fitness_Differ_Cohort_All,na.rm=TRUE)
sum(!df_summary$Fitness_Differ_BB_All,na.rm=TRUE)
sum(!df_summary$Fitness_Differ_BB_Cohort,na.rm=TRUE)
sum(!df_summary$Fitness_Differ_Absence_0_adj,na.rm=TRUE)
sum(!df_summary$Fitness_Differ_Absence_Count_0_adj,na.rm=TRUE)
sum(!df_summary$Fitness_Differ_q_Count_0_adj,na.rm=TRUE)

View(df_summary[,c("Absence","zScore_All_mean_0_adj",
                   "zScore_High",
                   "zScore_Low",
                   "Fitness_All_Absence_0_adj",
                   "Fitness_All_Count_0_adj")])

r1 <- df_summary |> 
  merge(df[,c("Child","cohort")])|> 
  pivot_longer(cols = c(Fitness_All,
                        Fitness_All_Absence,
                        Fitness_All_Absence_0,
                        Fitness_All_Absence_0_adj,
                        Fitness_All_Count_0_adj,
                        Fitness_All_Absence_Count_0_adj,
                        Fitness_q_All,
                        Fitness_q_Cohort,
                        Fitness_q_Cohort_T6,
                        Fitness_Cohort,
                        Fitness_Cohort_NA,
                        Fitness_BB),
               names_to = "Norm",values_to = "Result")|>
  group_by(Norm,Result,cohort)|>
  summarize(Number = n())|>
  pivot_wider(names_from=Norm,values_from = c(Number))|>
  t() |> as.data.frame()
r1

df_summary |> 
  group_by(Fitness_All_Absence_Count_0_adj,Fitness_All_Absence_0_adj,zScore_High,zScore_Low)|>
  summarize(N = length(unique(Child)),
         zScoreMean = mean(zScore_All_mean_0_adj))|> 
  mutate(check = Fitness_All_Absence_Count_0_adj == Fitness_All_Absence_0_adj)|> 
  filter(check ==FALSE)|> 
  select(-check)|>
  reactable(pagination = FALSE)

df_summary |> 
  group_by(Fitness_All_Absence_Count_0_adj,Fitness_q_All,zScore_High,qUpperAll,zScore_Low,qLowerAll)|>
  summarize(N = length(unique(Child)),
         zScoreMean = mean(zScore_All_mean_0_adj))|> 
  mutate(check = Fitness_All_Absence_Count_0_adj == Fitness_q_All)|> 
  filter(check ==FALSE)|> 
  select(-check)|>
  reactable(pagination = FALSE)


# wide format

df_wide <- df_long |>
  pivot_wider(id_cols = c(Child,Sex,Cohort,
                          School,Name,District,
                          Latitude,Longitude,
                          Gemeinden.Kennziffer,
                          Sport,Club,
                          club_1,club_2,club_3,
                          Inclusion),
              names_from = Component,
              values_from = c("score",
                              "zScore_All",
                              "zScore_All_adj",
                              "zScore_Cohort",
                              "zScore_BB")) |>
  merge(df_summary) 

df_wide |>
  filter(Fitness_All_Absence_Count_0_adj =="F")|>
  filter(Fitness_q_All == "T")|>
  select(qAll,
         Child,
         score_S20,
         zScore_All_S20,
         zScore_All_Star,
         score_Star,
         zScore_All_BPT,
         score_BPT,
         zScore_All_Run,
         score_Run,
         zScore_All_OLB,
         score_OLB,
         zScore_All_SLJ,
         score_SLJ) |>
  reactable()

df_long |> filter(Child == "C027529")|>
  select(Component,score,zScore_All,q_Upper_All,q_Lower_All)|>
  mutate(qU = ifelse(score>=q_Upper_All ,1,0),
         qL = ifelse( score <=q_Lower_All ,1,0))

# lost data
nrow(d) - nrow(df_wide)
```



## TODO Compare and plot different fitness classifications

- Diskussion Talentdefinition: 
  - ambitioniert = 5 Testteilnahmen und ...
  - oder reichen weniger aus?
- Förderbedarf: die an keinem Test teilnahmen  

```{r}
a<- df_wide |> dplyr::filter(is.na(Fitness_Cohort_NA))
# See the ?tippy documentation to learn how to customize tooltips
with_tooltip <- function(value, tooltip, ...) {
  div(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
      tippy(value, tooltip, ...))
}

library(reactable)
r1 <- df_summary |> 
  pivot_longer(cols = c(Fitness_All,
                        Fitness_All_Absence,
                        Fitness_All_Absence_0,
                        Fitness_All_Absence_0_adj,
                        Fitness_All_Count_0_adj,
                        Fitness_All_Absence_Count_0_adj,
                        Fitness_q_All,
                        Fitness_q_Cohort,
                        Fitness_Cohort,
                        Fitness_Cohort_NA,
                        Fitness_BB),
               names_to = "Norm",values_to = "Result")|>
  group_by(Norm,Result)|>
  summarize(Number = n())|>
  pivot_wider(names_from=Norm,values_from = c(Number))
r1
r2 <- t(r1) |> as.data.frame()
colnames(r2) <- r1[1,]
r2
r1|>
  select(-Fitness_All,-Fitness_All_Count_0_adj,-Fitness_Cohort,-Fitness_Cohort_NA)|>
   relocate(Result,
            Fitness_BB, 
            Fitness_All_Absence,
            Fitness_All_Absence_0,
            Fitness_All_Absence_0_adj,
            Fitness_All_Absence_Count_0_adj
           )|>
  reactable(
    columns = list(
      # Arithm. Mittel aller Test-Komponenten, na.rm = FALSE
      # - viele koennen nicht ausgewertet werden (NA)
      # - Überbewertung von Outlier-Test-Werten
      Fitness_BB = 
        colDef(header=with_tooltip(
          "Feste Norm Brandenburg 2016", 
          "Arithm. Mittel aller Test-Komponenten, na.rm = FALSE
       - viele koennen nicht ausgewertet werden (NA)
      - Überbewertung von Outlier-Test-Werten")),
      
      # Arithm. Mittel aller absolvierten Tests, na.rm = TRUE
      # + mehr auswertbare
      # - Ueberbewertung der absolvierten Tests
      # - Unterbewertung der fehlenden Tests (Rosinenpicker)
      # - Überbewertung von Outlier-Test-Werten
      Fitness_All_Absence = colDef(name="Rosinenpicker mean(na.rm=TRUE)"),
      
      # Arithm. Mittel mind. 3 Tests (Absence < 4)
      # + Penalty der Rosinenpicker, da deren Nicht-Tests auf z = 0 
      # (Mittelwert aller) gesetzt werden,
      # dadurch müssen potentielle Talente in anderen Tests umso stärker sein
      # + viele, die bei vielen Tests fehlten (geringe Ambition, Krankheit, 
      # Attest Drückeberger,...) und somit durch das Raster fielen, erhalten 
      # auch eine Klassifikation (Erfassung der geringen Teilnahme)
      # - Überbewertung von Outlier-Test-Werten
      Fitness_All_Absence_0 = colDef(name="Penalty Absence (mind. 3 Tests, NA -> 0)"),
      
      # Arithm. Mittel mind. 3 Tests (Absence < 4) und Outlier-Adjustments
      # + Adjustierung extremer Leistungen (oder potentieller Messfehler) 
      # außerhalb 3.29 * SD auf 3.29-fache Standardabweichung (0.1 %) (Deckeln)
      # - Abschwächung potentieller Inselbegabung
      Fitness_All_Absence_0_adj  =colDef(name = "Deckeln (3.29 * SD, 0.1 %)"),
      
      # Arithm. Mittel mind. 3 Tests (Absence < 4), Outlier-Adjustments und 
      # Test-Kontinuität (4 Tests Über- oder Unterdurchschnittlich) aber 
      # trotzdem nicht über abs(0.674 SD)
      # + Test-Kontinuität
      Fitness_All_Absence_Count_0_adj = colDef(name = "Honour Test-Kontinuität 
                                               (Anzahl überdurchschnittlicher
                                               Tests)")
      
      
      ),
    columnGroups = list(
    colGroup(name = "Fixed Norm (bis 2016)", 
               columns = c("Fitness_BB")),
    colGroup(name = "Dynamic Norm (2017-2021)", 
               columns = c(
                 "Fitness_All_Absence",
                 "Fitness_All_Absence_0",
                 "Fitness_All_Absence_0_adj",
                 "Fitness_All_Absence_Count_0_adj"))
    
    )
    
    )

# Dynamische vs. Feste Norm?!
  


df_wide |> 
 group_by(Cohort)|>
  summarise(Gesamtzahl = n(),
            `vollst. auswertbar` = sum((Sex=="m" | Sex == "w") & !is.na(Fitness_All)),
            `auswertbar` = sum((Sex=="m" | Sex == "w") & !is.na(Fitness_Cohort_NA)),
            `auswertbar Absence` = sum((Sex=="m" | Sex == "w") & Absence < 4 & !is.na(Fitness_Cohort_NA)),
            T_All = sum(Fitness_All=="T",na.rm=TRUE),
            T_All_Absence = sum(Fitness_All_Absence=="T",na.rm=TRUE),
            T_All_Absence_0 = sum(Fitness_All_Absence_0=="T",na.rm=TRUE),
            T_All_Absence_0_adj = sum(Fitness_All_Absence_0_adj=="T",na.rm=TRUE),
            T_All_Count_0_adj = sum(Fitness_All_Count_0_adj == "T",na.rm=TRUE),
            T_All_Absence_Count_0_adj= sum(Fitness_All_Absence_Count_0_adj == "T",na.rm=TRUE),
            T_Cohort = sum(Fitness_Cohort=="T",na.rm=TRUE),
            T_Cohort_NA = sum(Fitness_Cohort_NA=="T",na.rm=TRUE),
            T_BB = sum(Fitness_BB=="T",na.rm=TRUE),
            F_All = sum(Fitness_All=="F",na.rm=TRUE),
            F_All_Absence = sum(Fitness_All_Absence=="F",na.rm=TRUE),
            F_All_Absence_0 = sum(Fitness_All_Absence_0=="F",na.rm=TRUE),
            F_All_Absence_0_adj = sum(Fitness_All_Absence_0_adj=="F",na.rm=TRUE),
            F_All_Count_0_adj = sum(Fitness_All_Count_0_adj == "F",na.rm=TRUE),
            F_All_Absence_Count_0_adj= sum(Fitness_All_Absence_Count_0_adj == "F",na.rm=TRUE),
            F_Cohort = sum(Fitness_Cohort=="F",na.rm=TRUE),
            F_Cohort_NA = sum(Fitness_Cohort_NA=="F",na.rm=TRUE),
            F_BB = sum(Fitness_BB=="F",na.rm=TRUE),
            N_All = sum(Fitness_All=="N",na.rm=TRUE),
            N_All_Absence = sum(Fitness_All_Absence=="N",na.rm=TRUE),
            N_All_Absence_0 = sum(Fitness_All_Absence_0=="N",na.rm=TRUE),
            N_All_Absence_0_adj = sum(Fitness_All_Absence_0_adj=="N",na.rm=TRUE),
            N_All_Count_0_adj = sum(Fitness_All_Count_0_adj == "N",na.rm=TRUE),
            N_All_Absence_Count_0_adj= sum(Fitness_All_Absence_Count_0_adj == "N",na.rm=TRUE),
            N_Cohort = sum(Fitness_Cohort=="N",na.rm=TRUE),
            N_Cohort_NA = sum(Fitness_Cohort_NA=="N",na.rm=TRUE),
            N_BB = sum(Fitness_BB=="N",na.rm=TRUE))|>
  mutate(check_NA = T_Cohort_NA + F_Cohort_NA + N_Cohort_NA - auswertbar,
         check_Absence = T_All_Absence + F_All_Absence + N_All_Absence - `auswertbar Absence`,
         check_Absence_0 = T_All_Absence_0 + F_All_Absence_0 + N_All_Absence_0 - `auswertbar Absence`,
         check_Absence_0_adj = T_All_Absence_0_adj + F_All_Absence_0_adj + N_All_Absence_0_adj - `auswertbar Absence`,
         check_Absence_Count_0_adj = T_All_Absence_Count_0_adj + F_All_Absence_Count_0_adj + N_All_Absence_Count_0_adj - `auswertbar Absence`,
         check_Count_0_adj = T_All_Count_0_adj + F_All_Count_0_adj + N_All_Count_0_adj - `auswertbar Absence`,
       T_All_Absence_0_R = round(T_All_Absence_0 /`auswertbar Absence`*100),
       F_All_Absence_0_R = round(F_All_Absence_0 /`auswertbar Absence`*100),
       N_All_Absence_0_R = round(N_All_Absence_0 /`auswertbar Absence`*100))|>
  reactable(
    columns = list(
      Cohort = colDef(name="Jahr"),
      T_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      T_All_Absence = colDef(name = "Norm Absence: TH<br>2017-2022",
                           html = TRUE),
      T_All_Absence_0_adj = colDef(name = "Norm Absence 0 adj: TH<br>2017-2022",
                           html = TRUE),
      T_All_Count_0_adj = colDef(name = "Norm Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      T_All_Absence_Count_0_adj= colDef(name = "Norm Absence Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      T_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      T_Cohort_NA = colDef(name = "Norm: TH NA<br>Jahr",
                              html = TRUE),
      T_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE),
      # förderbedarf
      F_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      F_All_Absence = colDef(name = "Norm Absence: TH<br>2017-2022",
                           html = TRUE),
      F_All_Absence_0_adj = colDef(name = "Norm Absence 0 adj: TH<br>2017-2022",
                           html = TRUE),
      F_All_Count_0_adj = colDef(name = "Norm Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      F_All_Absence_Count_0_adj= colDef(name = "Norm Absence Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      F_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      F_Cohort_NA = colDef(name = "Norm: TH NA <br>Jahr",
                              html = TRUE),
      F_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE),
      
      # erwartungsgemäß
      N_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      N_All_Absence = colDef(name = "Norm Absence: TH<br>2017-2022",
                           html = TRUE),
      N_All_Absence_0_adj = colDef(name = "Norm Absence 0 adj: TH<br>2017-2022",
                           html = TRUE),
      N_All_Count_0_adj = colDef(name = "Norm Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      N_All_Absence_Count_0_adj= colDef(name = "Norm Absence Count 0 adj: TH<br>2017-2022",
                           html = TRUE),
      N_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      N_Cohort_NA = colDef(name = "Norm: TH NA <br>Jahr",
                              html = TRUE),
      N_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE)
    ),
    columnGroups = list(
      colGroup(name = "potentielle Talente", 
               columns = c("T_All", 
                           "T_All_Absence", 
                           "T_All_Absence_0", 
                           "T_All_Absence_0_adj",
                           "T_All_Count_0_adj",
                           "T_All_Absence_Count_0_adj",
                           "T_Cohort",
                           "T_Cohort_NA",
                           "T_BB")),
      colGroup(name = "eventuell Förderbedarf", 
               columns = c("F_All", 
                           "F_All_Absence", 
                           "F_All_Absence_0", 
                           "F_All_Absence_0_adj",
                           "F_All_Count_0_adj",
                           "F_All_Absence_Count_0_adj",
                           "F_Cohort",
                           "F_Cohort_NA",
                           "F_BB")),
      colGroup(name = "erwartungsgemäß", 
               columns = c("N_All",
                           "N_All_Absence", 
                           "N_All_Absence_0", 
                           "N_All_Absence_0_adj",
                           "N_All_Count_0_adj",
                           "N_All_Absence_Count_0_adj",
                           "N_Cohort",
                           "N_Cohort_NA",
                           "N_BB"))
    ))
```

## Final fitness classifikation 

### Summary data frame

```{r}
 
            
t1 <- df_wide |> 
   mutate(Club = tolower(Club))|>
  filter(Club == "ja" | Club == "nein")|>
 
  group_by(Cohort,District,School,Name,Sex,Club) |>
  summarise(Gesamtzahl = n(),
            `auswertbar` = sum((Sex=="m" | Sex == "w") & Absence < 4 & !is.na(Fitness_Cohort_NA)),
            T = sum(Fitness_All_Absence_0 =="T",na.rm=TRUE),
            F = sum(Fitness_All_Absence_0 =="F",na.rm=TRUE),
            N = sum(Fitness_All_Absence_0 =="N",na.rm=TRUE)
            ) |>
  mutate(T_rel = round(T/auswertbar*100),
         F_rel = round(F/auswertbar*100),
         N_rel = round(N/auswertbar*100)
         # check_rel = T_rel + F_rel + N_rel,
         # check = T + F + N - auswertbar
         )
with_tooltip2 <- function(value, tooltip) {
  tags$abbr(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
            title = tooltip,value)
}

library(tippy)
with_tooltip <- function(value, tooltip, ...) {
  div(style = "text-decoration: underline; text-decoration-style: dotted; cursor: help",
      tippy(value, tooltip, ...))
}
```

### Tables

#### Filter definitions
```{r}
# Render a bar chart in the background of the cell
bar_style <- function(width = 1, fill = "#e6e6e6", height = "75%",
                      align = c("left", "right"), color = NULL) {
  align <- match.arg(align)
  if (align == "left") {
    position <- paste0(width * 100, "%")
    image <- sprintf("linear-gradient(90deg, %1$s %2$s, transparent %2$s)", fill, position)
  } else {
    position <- paste0(100 - width * 100, "%")
    image <- sprintf("linear-gradient(90deg, transparent %1$s, %2$s %1$s)", position, fill)
  }
  list(
    backgroundImage = image,
    backgroundSize = paste("100%", height),
    backgroundRepeat = "no-repeat",
    backgroundPosition = "center",
    color = color
  )
}

bar_chart <- function(label, width = "100%", height = "1rem", fill = "#00bfc4", background = NULL) {
  bar <- div(style = list(background = fill, width = width, height = height))
  chart <- div(style = list(height = height,flexGrow = 1, marginLeft = "0rem",marginRight = "0.5rem", background = background), bar)
 # div(style = list(display = "flex", alignItems = "left"), label, chart)
div(div(style = list(display = "flex", 
                 align = "right"), paste0(label," %")),div(style = list(display = "flex", 
                 alignItems = "center"),chart))

}
# Source: https://glin.github.io/reactable/articles/custom-filtering.html
# 2022-03-23
# Custom range input filter with label and value
rangeFilter1 <- function(tableId, columnId, label, min, max, value = NULL, step = NULL, width = "200px") {
  value <- if (!is.null(value)) value else min
  inputId <- sprintf("filter_%s_%s", tableId, columnId)
  valueId <- sprintf("filter_%s_%s__value", tableId, columnId)
  oninput <- paste(
    sprintf("document.getElementById('%s').textContent = this.value;", valueId),
    sprintf("Reactable.setFilter('%s', '%s', this.value)", tableId, columnId)
  )
  
  div(
    tags$label(`for` = inputId, label),
    div(
      style = sprintf("display: flex; align-items: center; width: %s", validateCssUnit(width)),
      tags$input(
        id = inputId,
        type = "range",
        min = min,
        max = max,
        step = step,
        value = value,
        oninput = oninput,
        onchange = oninput, # For IE11 support
        style = "width: 100%;"
      ),
      span(id = valueId, style = "margin-left: 8px;", value)
    )
  )
}

# Source: https://glin.github.io/reactable/articles/custom-filtering.html
rangeFilter2 <- function(values, name) {
        tags$select(
          # Set to undefined to clear the filter
          onchange = sprintf("Reactable.setFilter('cars-select', '%s', event.target.value || undefined)", name),
          # "All" has an empty value to clear the filter, and is the default option
          tags$option(value = "", "Alle"),
          lapply(unique(values), tags$option),
          "aria-label" = sprintf("Filter %s", name),
          style = "width: 100%; height: 28px;"
        )
}

# Custom range input filter with label and value
rangeFilter <- function(tableId, columnId, label, min, max, value = NULL, step = NULL, width = "200px") {
  value <- if (!is.null(value)) value else min
  inputId <- sprintf("filter_%s_%s", tableId, columnId)
  valueId <- sprintf("filter_%s_%s__value", tableId, columnId)
  oninput <- paste(
    sprintf("document.getElementById('%s').textContent = this.value;", valueId),
    sprintf("Reactable.setFilter('%s', '%s', this.value)", tableId, columnId)
  )
  
  div(
    tags$label(`for` = inputId, label),
    div(
      style = sprintf("display: flex; align-items: center; width: %s", validateCssUnit(width)),
      tags$input(
        id = inputId,
        type = "range",
        min = min,
        max = max,
        step = step,
        value = value,
        oninput = oninput,
        onchange = oninput, # For IE11 support
        style = "width: 100%;"
      ),
      span(id = valueId, style = "margin-left: 8px;", value)
    )
  )
}

# Filter method that filters numeric columns by minimum value
filterMinValue <- JS("function(rows, columnId, filterValue) {
  return rows.filter(function(row) {
    return row.values[columnId] >= filterValue
  })
}")
# Filter method that filters numeric columns by minimum value
filterMinValue <- JS("function(rows, columnId, filterValue) {
  return rows.filter(function(row) {
    return row.values[columnId] >= filterValue
  })
}")

# Source: https://github.com/glin/reactable/blob/HEAD/vignettes/popular-movies/popular-movies.Rmd
# 2023-03-23
select_filter <- function(id, label, shared_data, group, choices = NULL,
                          width = "100%", class = "filter-input") {
  values <- shared_data$data()[[group]]
  keys <- shared_data$key()
  if (is.list(values)) {
    # Multiple values per row
    flat_keys <- unlist(mapply(rep, keys, sapply(values, length)))
    keys_by_value <- split(flat_keys, unlist(values), drop = TRUE)
    choices <- if (is.null(choices)) sort(unique(unlist(values))) else choices
  } else {
    # Single value per row
    keys_by_value <- split(seq_along(keys), values, drop = TRUE)
    choices <- if (is.null(choices)) sort(unique(values)) else choices
  }

  script <- sprintf("
    window['__ct__%s'] = (function() {
      const handle = new window.crosstalk.FilterHandle('%s')
      const keys = %s
      return {
        filter: function(value) {
          if (!value) {
            handle.clear()
          } else {
            handle.set(keys[value])
          }
        }
      }
    })()
  ", id, shared_data$groupName(), toJSON(keys_by_value))

  div(
    class = class,
    tags$label(`for` = id, label),
    tags$select(
      id = id,
      onchange = sprintf("window['__ct__%s'].filter(this.value)", id),
      style = sprintf("width: %s", validateCssUnit(width)),
      tags$option(value = "", "Alle"),
      lapply(choices, function(value) tags$option(value = value, value))
    ),
    tags$script(HTML(script))
  )
}

# https://glin.github.io/reactable/articles/custom-filtering.html
# 2023-02-23
# Creates a data list column filter for a table with the given ID
dataListFilter <- function(tableId, style = "width: 100%; height: 28px;") {
  function(values, name) {
    dataListId <- sprintf("%s-%s-list", tableId, name)
    tagList(
      tags$input(
        type = "text",
        list = dataListId,
        oninput = sprintf("Reactable.setFilter('%s', '%s', event.target.value || undefined)", tableId, name),
        "aria-label" = sprintf("Filter %s", name),
        style = style
      ),
      tags$datalist(
        id = dataListId,
        lapply(unique(values), function(value) tags$option(value = value))
      )
    )
  }
}

```

### Shared HTML Table
```{r}
# shared table
shared_data <- SharedData$new(t1)

# styles
sticky_style <- list(backgroundColor = "#f7f7f7")
sticky_style_r <- list(borderTop = "0px solid #eee",borderLeft = "0px solid #eee",borderRight = "0px solid #eee")
sticky_style_l <- list(borderLeft = "0px solid #eee")

# reactable
tbl <- reactable(
  shared_data,
  defaultColDef = colDef(
    headerStyle = sticky_style_r,
        align = "right",
        footerStyle = list(fontWeight = "bold"),
     #   maxWidth = 120,
        vAlign="top"),
  searchable = TRUE,
  resizable = TRUE,
  wrap = TRUE,
  showSortable = TRUE,
  bordered = FALSE,
  compact=TRUE,
  # details = function(index) {
  #t1$Name[index]},
  #  onClick = "select",
  height = 800,
  # defaultPageSize = 20,
  striped = TRUE,
  #elementId = "cars-vis-table",
  elementId = "cars-grouping-table",
  highlight = TRUE,
 
  filterable = FALSE,
 groupBy = c("Cohort"),
  columns = list(
    Cohort = colDef(name = "Jahr",
                    align="left",
                    filterable = FALSE),
    Sex = colDef(name="Geschlecht",
                 align="left",sortable = FALSE,
                 filterable=FALSE),
        Club = colDef(name="Verein",
                      sortable = FALSE,
                 filterable=FALSE,align="left"),
    Name = colDef(name = "Schule",
                  sortable = FALSE,
                  show=TRUE,
                  align="left",
                  style = "font-weight: 100",
                  # Show species under character names
                  cell = function(value, index) {
                    School<- t1$School[index]
                    School <- if (!is.na(School)) School else "Unknown"
                    div(
                      div(style = "font-weight: 100", value),
                      div(style = "font-size: 0.75rem", School)
                    )
                  }),
    School = colDef(show=FALSE,sortable = FALSE), #Schulnummer
  #  School = colDef(show=FALSE),
    District = colDef(name="Kreis",show=TRUE,align="left",sortable = FALSE),
    Gesamtzahl= colDef(name="N",
                       width=90,
                       align = "right",
              aggregate = "sum",
              html=TRUE,
            
           #   footer = function(values) 
            #    sprintf("&#x2211; %.0f", 
             #           #sum(shared_data$Gesamtzahl)
              #           sum(values)
                        
               #         )
                  footer = JS("function(colInfo) {
        var total = 0
        colInfo.data.forEach(function(row) {
          total += row['Gesamtzahl']
        })
        return '&#x2211; ' + total.toFixed(0)
      }")
              ),
  auswertbar= colDef(name="N<sub>a</sub>",
                     html=TRUE,
                     width=90,
                     header = with_tooltip("N<sub>a</sub>","auswertbare Datensätze"),
                       align = "right",
              aggregate = "sum",
           #   footer = function(values) 
            #    sprintf("&#x2211; %.0f", sum(values))
           #https://github.com/glin/reactable/issues/78
              footer = JS("function(colInfo) {
        var total = 0
        colInfo.data.forEach(function(row) {
          total += row['auswertbar']
        })
        return '&#x2211; ' + total.toFixed(0)
      }")
              ),
  T= colDef(align = "right",
             name="N<sub>T</sub>",
                     html=TRUE,
            width=75,
            aggregate = "sum",
          #  footer = function(values) 
         #     sprintf("%.0f", sum(values))
            footer = JS("function(colInfo) {
        var total = 0
        colInfo.data.forEach(function(row) {
          total += row['T']
        })
        return '&#x2211; ' + total.toFixed(0)
      }")
            ),
    F= colDef(align = "right",
             name="N<sub>F</sub>",
                     html=TRUE,
             width=75,
            aggregate = "sum",
          #  footer = function(values) 
         #     sprintf("%.0f", sum(values))
            footer = JS("function(colInfo) {
        var total = 0
        colInfo.data.forEach(function(row) {
          total += row['F']
        })
        return '&#x2211; ' + total.toFixed(0)
      }")
            ),
   N= colDef(align = "center",
             name="N<sub>E</sub>",
                     html=TRUE,
             width=75,
            aggregate = "sum",
          #  footer = function(values) 
         #     sprintf("%.0f", sum(values))
            footer = JS("function(colInfo) {
        var total = 0
        colInfo.data.forEach(function(row) {
          total += row['N']
        })
        return '&#x2211; ' + total.toFixed(0)
      }")
            ),
  F_rel =   colDef(aggregate = "mean",
                   width=85,
                   
                 #  headerStyle="font-size: 0.5rem",
      #              filterable = TRUE,
      #       filterMethod = JS("function(rows, columnId, filterValue) {
      #   return rows.filter(function(row) {
      #     return row.values[columnId] >= filterValue
      #   })
      # }"),
      # filterInput = function(values, name) {
      #   oninput <- sprintf("Reactable.setFilter('cars-grouping-table', '%s', this.value)", name)
      #   tags$input(
      #     type = "range",
      #     min = floor(min(values)),
      #     max = ceiling(max(values)),
      #     value = floor(min(values)),
      #     oninput = oninput,
      #     onchange = oninput, # For IE11 support
      #     "aria-label" = sprintf("Filter by minimum %s", name)
      #   )
      # },
                name="N<sub>F</sub>/N<sub>a</sub>&#8729;100",
                 html=TRUE,
                #   footer = function(values) 
                 #    sprintf("Mean: %.0f", mean(values)),
                   
                # Calculate the total Avg.Price as `sum(Price) / sum(Units)`
      footer = JS("function(colInfo) {
        var total = 0
        var foerder = 0
        colInfo.data.forEach(function(row) {
          total += row['auswertbar']
          foerder += row['F']
        })
        return '&Oslash; ' + (foerder/total*100).toFixed(0) + ' &#37;' 
      }"),
                   
                   format = colFormat(digits = 0, suffix = " &#37;"),
                   align = "right",
      
      
                   # cell = function(value) {
                   #   width <- paste0(value / max(t1$F_rel,na.rm = TRUE) * 100, "%")
                   #   bar_chart(value, width = width, fill = "#fc5185", background = "#e1e1e1")
                   # }
                   # 
      
      ),
  #  T_rel =   colDef(name = "T_rel", align = "left", cell = function(value) {
  #    width <- paste0(value / max(t1$F_rel,na.rm = TRUE) * 100, "%")
  #    bar_chart(value, width = width,background = "#e1e1e1")
  #  }),
  T_rel = colDef(aggregate = "mean",
                 width=85,
                 name="N<sub>T</sub>/N<sub>a</sub>&#8729;100",
                 html=TRUE,
                 format = colFormat(digits = 0, suffix = " &#37;"),
               #  footer = function(values) 
              #     sprintf("&Oslash; %.0f", mean(values)),
                 footer = JS("function(colInfo) {
        var total = 0
        var n = 0
        colInfo.data.forEach(function(row) {
          total += row['auswertbar']
          n += row['F']
        })
        return '&Oslash; ' + (n/total*100).toFixed(0) + ' &#37;' 
      }"),
            #     style = function(value) {
             #      bar_style(width = value / max(t1$T_rel,na.rm = TRUE),
            #fill = "#009ee3", color = "#000000",height = "1.5rem")
             #    },
                 # cell = function(value) {
                 #   width <- paste0(value / max(t1$T_rel,na.rm = TRUE) * 100, "%")
                 #   bar_chart(value, 
                 #             width = width, 
                 #             fill = "#009ee3", 
                 #             background = "#e1e1e1")
                 # },
      align = "right"),
  N_rel = colDef(aggregate = "mean",
                 name="N<sub>E</sub>/N<sub>a</sub>&#8729;100",
                 html=TRUE,
                 width=85,
    footer = JS("function(colInfo) {
        var total = 0
        var n = 0
        colInfo.data.forEach(function(row) {
          total += row['auswertbar']
          n += row['N']
        })
        return '&Oslash; ' + (n/total*100).toFixed(0) + ' &#37;' 
      }"),
    
    
 # cell = function(value) {
 #                     width <- paste0(value / max(t1$N_rel,na.rm = TRUE) * 100, "%")
 #                     bar_chart(value, 
 #                               width = width, 
 #                               fill = "#F9FF2B", 
 #                               background = "#e1e1e1")
 #                   },
 
 
    align = "right",
    format = colFormat(digits = 0, suffix = " &#37;")
    )
  ),
columnGroups = list(
  colGroup(
         
  name = "potentiell talentiert", 
           columns = c("T", 
                       "T_rel")),
  colGroup(name = "eventuell förderbedürftig", 
           columns = c("F", 
                       "F_rel")),
  colGroup(name = "erwartungsgemäß", 
           columns = c("N", 
                       "N_rel")),
  colGroup(name = "Gesamtzahl", 
           sticky="left",
           columns = c("Gesamtzahl", 
                       "auswertbar"))
  
 )
 )



# browsable shared table
browsable(
  div("Filter: ",
 # class = "movies",
  style="font-weight: bold",
  div(#style="display: flex",
    style="font-weight: normal; display: grid; grid-template-columns: 1fr 3fr 1fr 1fr; gap: 10px;",
    class = "filters",
  #  search_filter("filter_title", "Search titles", shared_movies, "title"),
    select_filter("filter_cohort", "Jahr", shared_data, "Cohort"),
    select_filter("filter_genres", "Kreis", shared_data, "District"),
  select_filter("filter_sex", "Geschlecht", shared_data, "Sex"),
   select_filter("filter_club", "Vereinsmitgliedschaft", shared_data, "Club")
  ),
br(),
  tagList(
    div(tags$label("Gruppierung", `for` = "cars-grouping-select")),
    tags$select(
      id = "cars-grouping-select",
    onchange = "Reactable.setGroupBy('cars-grouping-table', this.value ? [this.value] : [])",
  # onchange = "Reactable.setGroupBy('cars-grouping-table', ['Cohort', 'District'])"
      tags$option("Keine", value = ""),
      tags$option("Jahr", value = "Cohort"),
       tags$option("Kreis", value = "District"),
       tags$option("Geschlecht", value = "Sex"),
       tags$option("Schule", value = "Name"),
      tags$option("Vereinsmitgliedschaft", value = "Club"),
      #lapply(c( "Kreis", "Sex","Name"), tags$option)
    ),
    
  
 #   tags$hr("aria-hidden" = "true"),
#tags$hr(),
div(style="font-weight: normal;font-size: 0.875em",
  tbl))
))
```


#### Version: External filter buttons
```{r}

htmltools::browsable(
  tagList(
    div(
      div(tags$label("Filter Kreis", `for` = "cars-type-filter")),
      tags$select(
        id = "cars-type-filter",
        onchange = "Reactable.setFilter('cars-filter-table', 'District', this.value)",
        tags$option("Alle", value = ""),
        lapply(unique(t1$District), tags$option)
      )
    ),
    
    tags$hr("aria-hidden" = "true"),

    reactable(t1, groupBy = c("Cohort","District"),defaultPageSize = 5, elementId = "cars-filter-table")
 # rt1
  )
)

rt1 <- t1 |>
reactable(groupBy = c("Cohort","District"),
             searchable = TRUE,
            resizable = TRUE,
            wrap = TRUE,
            showSortable = TRUE,
            bordered = FALSE,
            compact=TRUE,
            details = function(index) paste("Details for row:", index),
            onClick = "expand",
            height = 800,
            # defaultPageSize = 20,
            striped = TRUE,
            highlight = TRUE,
            defaultColDef = colDef(footerStyle = list(fontWeight = "bold")),
            filterable = TRUE,
          #  defaultColDef = colDef(),
            columns = list(
              District = colDef(footer = "", 
                                sticky = "left"),
              School = colDef(footer = "", 
                              sticky = "left"),
              Name = colDef(footer = "", 
                              sticky = "left",
                              style = sticky_style_r,
                              headerStyle = sticky_style_r),
              Cohort = colDef(footer = "Summe", 
                              sticky = "left"),
              T = colDef(aggregate = "sum",
                         footer = function(values) 
                           sprintf("%.0f", sum(values))),
              F = colDef(aggregate = "sum",
                         footer = function(values) 
                           sprintf("%.0f", sum(values))),
              N = colDef(aggregate = "sum",
                         footer = function(values) 
                           sprintf("%.0f", sum(values))),
              T_rel = colDef(aggregate = "mean",
                             format = colFormat(digits = 0),
                             footer = function(values) 
                           sprintf("Mean: %.0f", mean(values))),
              F_rel = colDef(aggregate = "mean",
                             format = colFormat(digits = 0),
                             footer = function(values)
                           sprintf("%.0f", mean(values))),
              N_rel = colDef(aggregate = "mean",
                             format = colFormat(digits = 0),
                             footer = function(values) 
                           sprintf("%.0f", mean(values))),
           #   check = colDef(aggregate = "sum"),
              Gesamtzahl = colDef(aggregate = "sum",
                                  filterable = FALSE,
                                  sticky = "left",
                                  footer = function(values) 
                           sprintf("Summe: %.0f", sum(values))),
              auswertbar = colDef(aggregate = "sum",
                                  sticky = "left",
                              style = sticky_style_r,
                              headerStyle = sticky_style_r,
                                  footer = function(values) 
                           sprintf("%.0f", sum(values)))),
          
            columnGroups = list(
              colGroup (name="Teilnehmer",
                        columns=c("Gesamtzahl","auswertbar")),
      colGroup(name = "Schule", 
               columns = c("Name", 
                           "School")),
      colGroup(
        name = "Anzahl", 
               columns = c("T", 
                           "F",
                           "N"
                           # "check"
                           )),
      colGroup(name = "Anzahl bezogen auf auswertbar", 
               columns = c("T_rel", 
                           "F_rel",
                           "N_rel" 
                           # "check_rel"
                           ))))

|>
 reactablefmtr::add_title(paste0("Fitness (in Bearbeitung, Stand: ",Sys.Date(),")"))


```

## Crosstalk
```{r}

shared2 <- SharedData$new(t1)
# Create some filters
filter2a <- filter_checkbox(
    "filter2a", "Filter sex", shared2, ~Cohort)
browsable(div(
    style="display: grid; grid-template-columns: 1fr 2fr; gap: 10px;",
    filter2a, reactable(t1)))

browsable(tagList(
  rangeFilter(
    "cars-ext-range",
    "Cohort",
    "Filter by Minimum Cohort",
    floor(min(as.numeric(t1$Cohort))),
    ceiling(max(as.numeric(t1$Cohort)))
  ),
  
  reactable(
    t1,
    columns = list(
      Cohort = colDef(filterMethod = filterMinValue)
    ),
    defaultPageSize = 5,
    elementId = "cars-ext-range"
  )
))

browsable(div(
    style="display: grid; grid-template-columns: 1fr 2fr; gap: 10px;",
    filter2a, reactable(t1)))







htmltools::browsable(
  tagList(
    tags$button(
      "Show/hide more columns",
      onclick = "Reactable.setHiddenColumns('cars-vis-table', prevColumns => {
        return prevColumns.length === 0 ? ['Cohort', 'District', 'Sex'] : []
      })"
    ),
    reactable(
      t1,
      columns = list(
        Cohort = colDef(show = FALSE),
        District = colDef(show = FALSE),
        Sex = colDef(show = TRUE)
      ),
      elementId = "cars-vis-table"
    )
  )
)
```


# Vereinsmitgliedschaft 
```{r}
# lost data
club_not_selected <- dplyr::filter(df_debug, Club != "ja" & Club != "nein")
count(club_not_selected)

club <- df_wide |> 
  mutate(Club = tolower(Club)
       #  Cohort = as.numeric(Cohort)
         )|>
  filter(Club == "ja" | Club == "nein")|>
  group_by(Cohort,District,Name,Club) |>
 # group_by(Club) |>
  summarise(Gesamtzahl = n(),
            `auswertbar` = sum((Sex=="m" | Sex == "w") & !is.na(Fitness_Cohort_NA)),
            T = sum(Fitness_Cohort_NA=="T",na.rm=TRUE),
            F = sum(Fitness_Cohort_NA=="F",na.rm=TRUE),
            N = sum(Fitness_Cohort_NA=="N",na.rm=TRUE)
            ) |>
  mutate(T_rel = round(T/auswertbar*100),
         F_rel = round(F/auswertbar*100),
         N_rel = round(N/auswertbar*100),
         check_rel = T_rel + F_rel + N_rel,
         check = T + F + N - auswertbar)

club_table <- function (df,group) {
df |> reactable(groupBy = group,
              searchable = TRUE,
              filterable = TRUE,
            columns = list(T = colDef(aggregate = "sum"),
                           F = colDef(aggregate = "sum"),
                           N = colDef(aggregate = "sum"),
                           T_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           F_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           N_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           check = colDef(aggregate = "sum"),
                           Gesamtzahl = colDef(aggregate = "sum"),
                           auswertbar = colDef(aggregate = "sum")),
                           
            columnGroups = list(
      colGroup(name = "Anzahl", 
               columns = c("T", 
                           "F",
                           "N",
                           "check")),
      colGroup(name = "relative Anzahl", 
               columns = c("T_rel", 
                           "F_rel",
                           "N_rel",
                           "check_rel"))))|>
 reactablefmtr::add_title(paste0("Vereinsmitgliedschaft (in Bearbeitung, Stand: ",Sys.Date(),")"))
}

club_table(club,c("Cohort","District","Name")) 
club_table(club,c("Club","District","Name")) 

df_wide |> 
  group_by(Cohort,Club) |>
  summarise(Gesamtzahl = n(),
            `auswertbar` = sum((Sex=="m" | Sex == "w") & !is.na(Fitness_Cohort_NA)),
            T = sum(Fitness_Cohort_NA=="T",na.rm=TRUE),
            F = sum(Fitness_Cohort_NA=="F",na.rm=TRUE),
            N = sum(Fitness_Cohort_NA=="N",na.rm=TRUE)
            ) 

|>
  mutate(T_rel = round(T/auswertbar*100),
         F_rel = round(F/auswertbar*100),
         N_rel = round(N/auswertbar*100),
         check_rel = T_rel + F_rel + N_rel,
         check = T + F + N - auswertbar)|>
  reactable(groupBy = c("Cohort","District"),
              searchable = TRUE,
            columns = list(T = colDef(aggregate = "sum"),
                           F = colDef(aggregate = "sum"),
                           N = colDef(aggregate = "sum"),
                           T_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           F_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           N_rel = colDef(aggregate = "mean",
                                          format = colFormat(digits = 0)),
                           check = colDef(aggregate = "sum"),
                           Gesamtzahl = colDef(aggregate = "sum"),
                           auswertbar = colDef(aggregate = "sum")),
                           
            columnGroups = list(
      colGroup(name = "Anzahl", 
               columns = c("T", 
                           "F",
                           "N",
                           "check")),
      colGroup(name = "Anzahl bezogen auf auswertbar", 
               columns = c("T_rel", 
                           "F_rel",
                           "N_rel",
                           "check_rel"))))|>
 reactablefmtr::add_title(paste0("Fitness (in Bearbeitung, Stand: ",Sys.Date(),")"))



|>
  mutate(check_NA = T_Cohort_NA + F_Cohort_NA + N_Cohort_NA - auswertbar)|>
  reactable(
    columns = list(
      Cohort = colDef(name="Jahr"),
      T_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      T_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      T_Cohort_NA = colDef(name = "Norm: TH NA<br>Jahr",
                              html = TRUE),
      T_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE),
      # förderbedarf
      F_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      F_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      F_Cohort_NA = colDef(name = "Norm: TH NA <br>Jahr",
                              html = TRUE),
      F_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE),
      
      # erwartungsgemäß
      N_All = colDef(name = "Norm: TH<br>2017-2022",
                           html = TRUE),
      N_Cohort = colDef(name = "Norm: TH <br>Jahr",
                              html = TRUE),
      N_Cohort_NA = colDef(name = "Norm: TH NA <br>Jahr",
                              html = TRUE),
      N_BB = colDef(name = "Norm: BB <br> 2017",
                          html = TRUE)
    ),
    columnGroups = list(
      colGroup(name = "potentielle Talente", 
               columns = c("T_All", 
                           "T_Cohort",
                           "T_Cohort_NA",
                           "T_BB")),
      colGroup(name = "eventuell Förderbedarf", 
               columns = c("F_All", 
                           "F_Cohort",
                           "F_Cohort_NA",
                           "F_BB")),
      colGroup(name = "erwartungsgemäß", 
               columns = c("N_All", 
                           "N_Cohort",
                           "N_Cohort_NA",
                           "N_BB"))
    ))
```


```{r}
p1<-df_long %>%
  group_by(Component,Cohort,Sex) %>%
  summarise(score_mean = mean(score,na.rm=TRUE),
            score_sd   = sd(score,na.rm = TRUE)) %>%
ggplot(aes(x=Cohort,y=score_mean))+
#  geom_violin()+
  geom_point()+
 # geom_errorbar(aes(ymin=score_mean-score_sd,ymax=score_mean+score_sd))+
  facet_wrap(vars(Component,Sex),scales="free")

plotly::ggplotly(p1)
df_wide %>%
  group_by(Fitness,Club,Cohort) %>%
  summarise(Anzahl = n()) %>%
  kbl()

df_long %>%
  group_by(Component,Cohort,Sex) %>%
  summarise(score_mean = mean(score,na.rm=TRUE)) %>%
  kbl()

%>%
  rename(Vereinsmitgliedschaft=Club,
         `Fitness Level` = talent_labels) 

club_talents %>%
  kbl() %>% 
  kable_styling("striped") 

ggplot(data2,aes(x=Club,fill=talent_labels))+
  geom_bar(aes(y=(..count..)))+
  geom_text(stat='count', 
         aes(label=paste(scales::percent(..count../sum(..count..),1),
                         "\n(N=",..count..,")",sep="")),
            position = position_stack(vjust = 0.5))+
  scale_fill_manual(values = c( "#808080","#ff6961","#8BC6FC"))+
  xlab("Vereinsmitgliedschaft")+  
  ylab("Anzahl vollständiger Datensätze")+
  guides(fill=guide_legend(title="Fitness-Level"))+
  theme(legend.position = "right")
```


# Updates
+ 2023-03-14: Erstellen der Datei
